/* FIXME: 使用 PHDRS 设置段的 RWX 属性 */
SECTIONS
{
    /* 内存分页的理想情况是，内核与每个用户程序有各自独立的页目录。问题在于使用中断从用户态切换到内核态时，
       CPU 不会自动将“用户程序页目录”切换成“内核页目录”，也就导致了内存访问错误。
       而有一种名为 Higher Half Kernel 的结构可以解决这一问题。
       我们将内存进行 3:1 分割，即 0-3 GiB 属于用户程序，3-4 GiB 属于内核空间。然后在用户程序的页目录
       里让 3-4 GiB 范围的页表映射到内核空间，将用户空间和内核空间存放在同一个页目录中，这样切换到内核态
       时就不需要切换页目录了。每个用户程序依旧有独立的页目录，只不过他们在 3-4 GiB 范围内都映射着同一个
       内核空间。

       由于 0-3 GiB 属于用户程序，为了不侵占用户空间，“内核的地址”必须都在 3 GiB 以上。所谓“内核的地址”
       指的是内核程序的变量名、函数名和汇编标签等，这些符号都会被链接器转换为具体地址。为了保证他们都在
       3 GiB 以上，就需要在链接脚本（也就是这个文件）修改链接地址。

       受制于机器内存大小，我们不能直接将内核加载到 3-4 GiB 的物理地址。但是，我们可以先将内核加载到低段
       物理地址（比如 1 MiB 以上），再通过分页映射把内核访问的 3-4 GiB 线性地址映射到内核程序所在的物理
       地址。
       为了实现这一功能，我们需要把内核分为两个部分。第一部分链接到实际加载的物理地址（比如 1 MiB），用于
       建立内核页表映射，把内核访问的 3-4 GiB 线性地址映射到内核所在的物理地址。第二部分链接到 3 GiB 以
       上，作为内核程序的主体。 */

    . = 0x100000; /* 初始地址为 1 MiB */

    /* 程序需要有一部分链接到实际的加载地址，用于初始化页表映射 */
    .lower.text : 
    {
        *(.lower.text)
    }

    /* 代码中的函数名、变量名、汇编标签等内容实际上都会被链接器转换为地址值，
       将后续内核程序链接地址增加 3 GiB，让内核“认为”自己运行在 3 GiB 以上
       的空间，然后通过页表将 3 GiB 以上的线性地址转换到实际物理地址 */
    . += 0xC0000000;

    /* AT(...) 用于在 ELF 文件中表示期望的加载地址，将地址减少 3 GiB 
       消除刚刚增加的偏移，表示希望将内核加载到低段内存 */
	.text : AT (ADDR (.text) - 0xC0000000)
	{
		*(.text)
	}

	.rodata : AT (ADDR (.rodata) - 0xC0000000)
	{
		*(.rodata)
	}

	.data : AT (ADDR (.data) - 0xC0000000)
	{
		*(.data)
	}

	.bss : AT (ADDR (.bss) - 0xC0000000)
	{
		*(COMMON)
		*(.bss)
	}
}
