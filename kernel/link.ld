/* FIXME: 使用 PHDRS 设置段的 RWX 属性 */
SECTIONS
{
    /* 内存分页的理想情况是，内核与每个用户程序有各自独立的页目录。但是使用中断从用户态切换到内核态会遇
       到一个问题，即中断门和陷阱门并不会自动将“用户程序页目录”切换成“内核页目录”，从而导致内存访问出错。
       触发中断自动切换页目录的功能只能通过任务门实现，但任务门作为被淘汰的旧特性有许多缺点。

       而有一种名为 Higher Half Kernel 的结构可以解决这个问题。
       方法就是在用户程序的页目录中专门拿一些页表映射内核空间，这样切换到内核态时就不用切换页目录了。
       由于低段虚拟地址要留给用户程序，所以内核就要被映射到高段虚拟地址之中。常见的方法是 3:1 分割，
       即 0-3 GiB 属于用户程序，3-4 GiB 属于内核。

       受制于实际内存大小，不可能总是将内核加载到 3-4 GiB 的物理内存。所以，我们需要先将内核加载到低段
       物理地址（比如 1 MiB），再通过分页映射把内核访问的高段虚拟地址映射到内核程序所在的低段物理地址。 */

    . = 0x100000; /* 初始地址为 1 MiB */

    .text.lower : AT(ADDR(.text.lower))
    {
        *(.text.lower)
    }

    .data.lower : AT(ADDR(.data.lower))
    {
        *(.data.lower)
    }

    /* 将后续内核程序链接地址增加 3 GiB，让内核以为自己运行在 3 GiB 以上
       的空间，就能通过访问 3-4 GiB 的页表访问到实际内核地址 */
    . += 0xC0000000;

    /* AT(...) 用于在 ELF 文件中表示期望的加载地址，将地址减少 3 GiB 
       消除刚刚增加的偏移，表示希望将内核加载到低段内存 */
	.text ALIGN (4K) : AT (ADDR (.text) - 0xC0000000)
	{
		*(.text)
	}

	.rodata ALIGN (4K) : AT (ADDR (.rodata) - 0xC0000000)
	{
		*(.rodata)
	}

	.data ALIGN (4K) : AT (ADDR (.data) - 0xC0000000)
	{
		*(.data)
	}

	.bss ALIGN (4K) : AT (ADDR (.bss) - 0xC0000000)
	{
		*(COMMON)
		*(.bss)
	}
}
